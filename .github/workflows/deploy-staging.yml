name: Docker Deployment Workflow

on:
  push:
    branches:
      - main

jobs:
  build_and_push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Test Docker Image
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/my-app:$GITHUB_SHA .
          docker run --rm ${{ secrets.DOCKER_USERNAME }}/my-app:$GITHUB_SHA /bin/bash -c "run_tests.sh"  # Replace with actual test command

      - name: Push Docker Image
        run: |
          docker push ${{ secrets.DOCKER_USERNAME }}/my-app:$GITHUB_SHA

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    steps:
      - name: Set up SSH for Deployment
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SERVER_PASSWORD }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
        env:
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}

      - name: SSH into the Deployment Server and Deploy Docker Image
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USERNAME }}@${{ secrets.SERVER_IP }} << 'EOF'
            # Stop and remove the old container (v1) if exists
            docker stop my-app-v1 || true
            docker rm my-app-v1 || true

            # Pull the new Docker image
            docker pull ${{ secrets.DOCKER_USERNAME }}/my-app:$GITHUB_SHA

            # Run the new container (v2) on a different port (8081)
            docker run -d --name my-app-v2 -p 8081:80 ${{ secrets.DOCKER_USERNAME }}/my-app:$GITHUB_SHA

            # Update Nginx configuration to route traffic to the new container
            sed -i 's/8080/8081/' /etc/nginx/sites-available/default  # Update to the new port

            # Reload Nginx to apply changes
            nginx -s reload

            # Validate the new container is working
            curl -f http://localhost:8081 || exit 1  # Exit with error if validation fails

            # Remove the old container (v1) after successful validation
            docker stop my-app-v1
            docker rm my-app-v1
          EOF

  rollback:
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    steps:
      - name: Rollback to the old version
        run: |
          sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USERNAME }}@${{ secrets.SERVER_IP }} << 'EOF'
            # Stop and remove the new container (v2) if exists
            docker stop my-app-v2 || true
            docker rm my-app-v2 || true

            # Rollback to the old container (v1) and restart it
            docker run -d --name my-app-v1 -p 8080:80 ${{ secrets.DOCKER_USERNAME }}/my-app:v1

            # Reload Nginx to route traffic back to v1
            nginx -s reload
          EOF
